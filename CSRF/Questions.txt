- What is CSRF?
    An attack that forces the user to execute an unwanted action.

- What does it target?
    State change, not data theft, since the attacker cannot see the response associated with the request. More likely to be targetted are: social media, anything that transfer money.

- What kind of action the user could be executing against its will?
    Password or email address change, fund transfer, etc. If the victim is an admin, the entire application can be at risk.

- How does it work?
    In many websites, browser requests automatically include AuthToken, Windows credentials, session cookie, etc. Therefore, the server has no way to know if the request comes from the legetimate user or if the request has been forged.

- Is it possible to store a CSRF attack?
    Yes, into an image or an iframe if there is a field that accepts HTML. Therefore, a combination of XSS and CSRF is possible.

- Can any HTTP verb be affected by CSRF?
    Yes

- Give 5 mitigation techniques that do NOT work.
    Ensuring the requests originate from the same source IP address. Pointless since the exploit depends on the requests to come from the same origin. And an IP address of a legetimate user can change, even during a session.
    Using HTTPS
    Using a secret cookie. There is no "secret" cookie, they are included in all requests (if the path value matches).
    Only accepting POST requests. The logic: an attacker cannot forge a POST request. But there are techniques that comes around this problem: hosted on the attacker site with hidden fields, which are trigered with JS or the tricked user.
    URL re-writing. The user's credentials are exposed in the URL.
    Checking the referer header
        - Why is it not safe?
            The referer header can be spoofed in a CSRF attack. 
        - What are the limitations?
            It is a weaker form of CSRF because of open redirects vulnaribilities can be used to exploit GET requests. It can also be badly implemented: if the refere was HTTPS and the request is over HTTP, the referer header is omitted. XSS can be used to bypass a referer check.

- Give an example with a GET request:
    GET http://bank.com/transfer.do?acct=SOMEONE&amount=100 HTTP/1.1

    to

    GET http://bank.com/transfer.do?acct=ATTACKER&amount=100000 HTTP/1.1

- Give an example with a POST request:
    The only difference with GET is how the request is executed by the victim.

    POST http://bank.com/transfer.do HTTP/1.1

    acct=BOB&amount=100

    This cannot be executed by the victim in an image, but it can in a form.

- Give an example of an attack website for a POST:
<html>
    <body>
        <form action=”https://mdsec.net/auth/390/NewUserStep2.ashx” method=”POST”>
            <input type=”hidden” name=”realname” value=”daf”>
            <input type=”hidden” name=”username” value=”daf”>
            <input type=”hidden” name=”userrole” value=”admin”>
            <input type=”hidden” name=”password” value=”letmein1”>
            <input type=”hidden” name=”confirmpassword” value=”letmein1”>
        </form>
        <script> document.forms[0].submit();</script>
    </body>
</html> 

- Give an example of an attack website for a GET:
<html>
    <body>
        <img href="https://mdsec.net/bidding.aspx?bid=100"/>
    </body>
</html> 

- How does an attacker create a CSRF for a PUT?
    - With a script that creates and send the request.

- Name 3 ways to solicitate the user to click on the malicious link.
    Sending an email
    Planting the URL or the script in a page likely to be visited by the victim while she is logged on the targeted website.
    With an iframe on a malicius site.

- How could it be included in an image?
    <img src="http://bank.com/transfer.do?acct=MARIA&amount=100000" width="0" height="0" border="0">

- How could the URL be executed without it to be clicked by the user?
    Include an image (can be 0 x 0) in an email that you send to the user. The link will be executed by the browser automatically. This is why emails from unknown providers have the images blocked by default nowadays.

    <img src="http://bank.com/transfer.do?acct=MARIA&amount=100000" width="0" height="0" border="0">

- How can you mitigate the CSRF attack?
    Synchronizer Token Pattern:
        - How does it work?
            Any state changing operation requires a secure random token (ie a CSRF token).
            Characteristics of the token: Unique per user and per user session. Tied to a single user session. Large random value. Generated by a secure cryptographic random number generator. It is added as a hidden field in forms or within the URL for each GET requests.
            The server rejects the request if the validation does not work. If it does not work, the event should be logged as a potential CSRF attack.
        - How could the attacker overcome this?
            By guessing the random token. Or find a token generation pattern. Via XSS.
        - Only works if...?
            The website uses TLS.
        - Is it suitable to use a per request token instead of a per session token?
            If the lost of usability is not a concern or is less important than the protection of the user, then yes. For example, the back button would not work and it will be registered as a false CSRF.
        - How could it potentially be leaked?
            Browser history, HTTP log files, in source code of the client page (in hidden input tag)
            - How could it happen over HTTPS?
                Broken TLS/SSL
                Via referer. If the referer header is parsed by a linked site, it will be easy to launch (even automate) a CSRF attack since the referer header contains the website and the CSRF token.
                Solution?
                    - Use POST instead of GET for requests that requires CSRF tokens.
        - How to detect an attack using this token?
            If the server receive too many invalid CSRF tokens in a row, log the attack and block the user. It prevents brute forcing the token from the server side perspective.
            - Does it totally prevent brute forcing the token?
                No, it can be brute forced client side if the token is in the URL. If the client has visited a URL that contains a CSRF token. The attacker can perform a brute-force attack from his own page. A script on the attaker's page dynamically creates hyperlinks to the relevant URL on the target application, including a different value for the anti-CSRF token in each link. Then it tests if a link has been visited, if so, then the attacker has found the CSRF token.
        - How to implement the pattern?
            Double Submit Cookies: Set a random value in both a cookie and as a request parameter, with the server verifying that both values are equal. On authentication, the site generate a pseudorandom value and set it as a cookie. The site then require that every sensitive submission include this random value as a hidden form value (or other request parameter) and also as a cookie value.
            Encrypted Token Pattern: Leverage encryption rather then comparision. After successful authentication, the server generates a unique Token comprised of the user's ID, a timestamp value, and a nonce, using a unique key available only on the server. The token is returned to the client and embedded in a hidden field. Subsequent requests include this token in the request-header (ajax call), non ajax call form-based requests will implicitly persist the Token in its hidden field. When the server receives the Token, it decrypts it (a fail suggest an intrusion attempt), user ID is compared to the logged iser, the time stamp is compared to the current time (prevents replay attacks). This approach circumvaint the cookie-subdomain and HTTPONLY issues of the previous option.

    Checking the origin header
        - What is the difference with the referer header?
            Unlike the referer header, it will be sent over HTTPS all the time.

    Challenge response
        - What is a challenge response and give examples. What is the limitation?
            CAPTCHA, re-authentication, one-time token. It is a very strong defense angainst CSRF, but it impacts user experience.

- Why not use the session id cookie for CSRF protection?
    Because the CSRF token (in cookie) needs to be accessed via JS, and we do not want the session to not have the HttpOnly flag.

- Why is the CSRF token needed to be added in in request (and not only in the cookie)?
    Because a cookie is sent with every requests, regardless of whether the request was initiated by the original site or by a third party site. But having the token in the request itself, an attacking site cannot generate valid requests anymore as they cannot get hold on the user's token

- What are the end-user best practices to prevent CSRF?
    Logoff immediately after using a web application. Do not allow your browser to save username/pswd and do not allow sites to remember your login. Do not use the same browser to access sensitive applications and to surf the Internet. Incognito mode.

- How can you test for CSRF vulnerabilities?
    Create an html page containing the request to the target site. Make sure the valid user is logged in the application. Induce him to follow the link pointing to the URL to be tested. Check if the web server executed the request.

- What is the difference between CSRF and clickjacking?
    - CSRF: the browser does all the work. The user does nothing. Once the download of a page as started, then it is done.
    - Clickjacking: actually need the user to click on something for things to happen. By putting a layer over the page (ex: iframe)

- Is it more about tricking the user or the browser?
    - The browser

- Can CSRF be persisted?
    - Yes, even on a legitimate website with a stored XSS.

- Does the same-origing policy mitigate CSRF?
    No, it does not prohibit one website from issuing requests to a different domain. It prevents the originating website from processing the responses to cross-domain requests.

- What makes CSRF possible?
    Primarily when the application rely solely on HTTP cookies for tracking sessions.

- What are the situations in which XSS vulnerabilitues can be exploited to defeat anti-CSRF defenses?
    Stored XSS within defended functionnality: JS injected via the stored attack can directly read the tokens contained within the same response that the script appears in.
    Stored XSS within non defended functionnality (how to retrieve token of defended parts): Ex: 2 steps transaction, first one does not have a CSRF token. The stored script execute the first request, retrieve the token and use it for the second request. 
    CSRF token tied to the user, not the session: The attaker logs in, CSRF the user to log with the attaker's credentials, run the XSS that logs the user out so that the right credentials are entered, the user is XSSed
    Same problem as above, but if the attacker is able to inject cookies into the user browser, he can directly set them with his session token and anti-CSRF token.

- What is UI redress?
    Also known as clickjacking, it is a way to get around the anti-CSRF token, for example, by using an iframe (the attacker's web page loads the application within an iframe, overlaying the real application with the attacker's page UI), since the point of origin is the traget website.

    - Can the attacker script read the token in that case?
        No, because of the same-origin policy

    - What is framebusting?
        A way to mitigate the iframe issue with code. But it as been proved that an attacker can circonvaint that, since he owns the top level page (for example, to change the value of top.location).

    - How to mitigate UI redress?
        Use the X-Frame-Options response header (deny or sameorigin), but there are browsers restrictions (not all version supports it, therefore some application do framebusting as well)
        Do not overlook mobile version wahh-app.com/chat/ vs app.com/mobile/chat/

- Does the CSP (HTML 5) header helps to mitigate CSRF?
    Yes, if used properly. Ex: specify the script source, image, css, etc.